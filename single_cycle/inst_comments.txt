// 0x000   | 00A00093     | addi x1, x0, 10        # x1 = 10
// 0x004   | 00500113     | addi x2, x0, 5         # x2 = 5  
// 0x008   | FFD00193     | addi x3, x0, -3        # x3 = -3
// 0x00C   | 00F00213     | addi x4, x0, 15        # x4 = 15
// 0x010   | 002082B3     | add  x5, x1, x2        # x5 = 10 + 5 = 15
// 0x014   | 40208333     | sub  x6, x1, x2        # x6 = 10 - 5 = 5
// 0x018   | 0040F3B3     | and  x7, x1, x4        # x7 = 10 & 15 = 10
// 0x01C   | 0040E433     | or   x8, x1, x4        # x8 = 10 | 15 = 15
// 0x020   | 0040C4B3     | xor  x9, x1, x4        # x9 = 10 ^ 15 = 5
// 0x024   | 00209533     | sll  x10, x1, x2       # x10 = 10 << 5 = 320
// 0x028   | 0020D5B3     | srl  x11, x1, x2       # x11 = 10 >> 5 = 0
// 0x02C   | 4021D633     | sra  x12, x3, x2       # x12 = -3 >>> 5 = -1
// 0x030   | 0020A6B3     | slt  x13, x1, x2       # x13 = (10 < 5) = 0
// 0x034   | 00112733     | slt  x14, x2, x1       # x14 = (5 < 10) = 1
// 0x038   | 0011B7B3     | sltu x15, x3, x1       # x15 = (0xFFFFFFFD < 10) = 0
// 0x03C   | 01408813     | addi x16, x1, 20       # x16 = 10 + 20 = 30
// 0x040   | 00727893     | andi x17, x4, 7        # x17 = 15 & 7 = 7
// 0x044   | 0200E913     | ori  x18, x1, 32       # x18 = 10 | 32 = 42
// 0x048   | 00F0C993     | xori x19, x1, 15       # x19 = 10 ^ 15 = 5
// 0x04C   | 00209A13     | slli x20, x1, 2        # x20 = 10 << 2 = 40
// 0x050   | 0010DA93     | srli x21, x1, 1        # x21 = 10 >> 1 = 5
// 0x054   | 4011DB13     | srai x22, x3, 1        # x22 = -3 >>> 1 = -2  
// 0x058   | 00F0AB93     | slti  x23, x1, 15      # x23 = (10 < 15) = 1
// 0x05C   | 00A1BC13     | sltiu x24, x3, 10      # x24 = (0xFFFFFFFD < 10) = 0
// 0x060   | 10000C93     | addi x25, x0, 256      # x25 = 0x100 (base addr)
// 0x064   | 001CA023     | sw   x1, 0(x25)        # Store x1 (10) at [0x100]
// 0x068   | 002CA223     | sw   x2, 4(x25)        # Store x2 (5) at [0x104]
// 0x06C   | 005CA423     | sw   x5, 8(x25)        # Store x5 (15) at [0x108]
// 0x070   | 000CAD03     | lw   x26, 0(x25)       # Load from [0x100] to x26 (10)
// 0x074   | 004CAD83     | lw   x27, 4(x25)       # Load from [0x104] to x27 (5)
// 0x078   | 008CAE03     | lw   x28, 8(x25)       # Load from [0x108] to x28 (15)
// 0x07C   | 01A08863     | beq  x1, x26, 16       # Branch if x1 == x26 (should branch)
// 0x080   | 3E700E93     | addi x29, x0, 999      # Should be skipped
// 0x084   | 22B00E93     | addi x29, x0, 555      # x29 = 555 (executed)
// 0x088   | 00208463     | beq  x1, x2, 8         # Branch if x1 == x2 (should not branch)
// 0x08C   | 30900F13     | addi x30, x0, 777      # x30 = 777 (executed)
// 0x090   | 008000EF     | jal  x31, 8            # Jump to function, save return addr
// 0x094   | 06408093     | addi x1, x1, 100       # x1 = x1 + 100 (after return)
// 0x098   | 00000063     | beq  x0, x0, 0         # Infinite loop
// 0x09C   | 03210113     | addi x2, x2, 50        # x2 = x2 + 50
// 0x0A0   | 000F8067     | jalr x0, x31, 0        # Return to caller


Expected Results
After execution, the registers should contain:

x1: 110 (10 + 100)
x2: 55 (5 + 50)
x29: 555 (from successful branch)
x30: 777 (from unsuccessful branch path)
x26, x27, x28: Values loaded from memory (10, 5, 15)